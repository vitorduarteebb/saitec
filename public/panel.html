<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Automa√ß√£o SAITEC - Painel de Tend√™ncias</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0a0a0a;
            --bg-secondary: #1a1a1a;
            --bg-tertiary: #252525;
            --text-primary: #ffffff;
            --text-secondary: #b0b0b0;
            --accent-primary: #25F4EE;
            --accent-secondary: #FF0050;
            --accent-success: #00ff88;
            --border-color: #333333;
            --shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
            color: var(--text-primary);
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: var(--bg-secondary);
            border-radius: 16px;
            box-shadow: var(--shadow);
            padding: 0;
            overflow: hidden;
            border: 1px solid var(--border-color);
        }

        header {
            background: linear-gradient(135deg, #1a1a1a 0%, #252525 100%);
            padding: 30px 40px;
            border-bottom: 2px solid var(--border-color);
            position: relative;
            overflow: hidden;
        }

        header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary), var(--accent-primary));
            animation: shimmer 3s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
        }

        .header-left h1 {
            font-size: 32px;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 8px;
            letter-spacing: -0.5px;
        }

        .header-left .subtitle {
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 500;
        }

        .version-badge {
            display: inline-block;
            padding: 6px 14px;
            background: var(--bg-tertiary);
            border: 1px solid var(--accent-primary);
            border-radius: 20px;
            color: var(--accent-primary);
            font-size: 12px;
            font-weight: 600;
            margin-top: 8px;
            letter-spacing: 0.5px;
        }

        .controls {
            padding: 30px 40px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        label {
            font-weight: 500;
            font-size: 14px;
            color: var(--text-secondary);
        }

        select {
            padding: 10px 16px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 14px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.3s;
            min-width: 150px;
        }

        select:hover {
            border-color: var(--accent-primary);
            background: var(--bg-secondary);
        }

        select:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(37, 244, 238, 0.1);
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--accent-primary), #1dd9d4);
            color: #000;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(37, 244, 238, 0.4);
        }

        .btn-download {
            background: linear-gradient(135deg, var(--accent-secondary), #ff3366);
            color: white;
        }

        .btn-download:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 0, 80, 0.4);
        }

        .tabs {
            display: flex;
            gap: 10px;
            padding: 20px 40px 0;
            border-bottom: 2px solid var(--border-color);
        }

        .tab-btn {
            padding: 12px 24px;
            background: transparent;
            color: var(--text-secondary);
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .tab-btn:hover {
            color: var(--text-primary);
            background: var(--bg-tertiary);
        }

        .tab-btn.active {
            color: var(--accent-primary);
            border-bottom-color: var(--accent-primary);
            background: var(--bg-tertiary);
        }

        .tab-content {
            padding: 0;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .filter-group label {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-secondary);
        }

        .filter-group input,
        .filter-group select {
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 14px;
            transition: all 0.3s;
        }

        .filter-group input:focus,
        .filter-group select:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(37, 244, 238, 0.1);
        }

        .status {
            padding: 16px 40px;
            border-radius: 0;
            font-size: 14px;
            font-weight: 500;
            display: none;
            transition: all 0.3s;
        }

        .status.loading {
            background: rgba(37, 244, 238, 0.1);
            color: var(--accent-primary);
            border-bottom: 2px solid var(--accent-primary);
        }

        .status.error {
            background: rgba(255, 0, 80, 0.1);
            color: var(--accent-secondary);
            border-bottom: 2px solid var(--accent-secondary);
        }

        .status.success {
            background: rgba(0, 255, 136, 0.1);
            color: var(--accent-success);
            border-bottom: 2px solid var(--accent-success);
        }

        /* Barra de Progresso Melhorada */
        .progress-container {
            margin-top: 12px;
            width: 100%;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: var(--bg-tertiary);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary), var(--accent-primary));
            background-size: 200% 100%;
            width: 0%;
            transition: width 0.5s ease;
            border-radius: 10px;
            animation: progressShine 2s infinite;
            box-shadow: 0 0 10px rgba(37, 244, 238, 0.5);
        }

        @keyframes progressShine {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .progress-text {
            margin-top: 8px;
            font-size: 12px;
            color: var(--text-secondary);
            display: flex;
            justify-content: space-between;
        }

        .table-container {
            overflow-x: auto;
            background: var(--bg-secondary);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }

        thead {
            background: var(--bg-tertiary);
            border-bottom: 2px solid var(--border-color);
        }

        th {
            padding: 16px;
            text-align: left;
            font-weight: 600;
            color: var(--text-primary);
            white-space: nowrap;
            text-transform: uppercase;
            font-size: 12px;
            letter-spacing: 0.5px;
        }

        td {
            padding: 16px;
            border-bottom: 1px solid var(--border-color);
            color: var(--text-secondary);
        }

        tbody tr {
            transition: all 0.2s;
        }

        tbody tr:hover {
            background: var(--bg-tertiary);
            transform: scale(1.01);
        }

        .trend-title {
            font-weight: 500;
            color: var(--text-primary);
            max-width: 350px;
            line-height: 1.4;
        }

        .hashtag {
            color: var(--accent-primary);
            font-weight: 600;
        }

        .origin-badge {
            display: inline-block;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .origin-tiktok {
            background: rgba(37, 244, 238, 0.2);
            color: var(--accent-primary);
            border: 1px solid var(--accent-primary);
        }

        .origin-pipiads {
            background: rgba(255, 0, 80, 0.2);
            color: var(--accent-secondary);
            border: 1px solid var(--accent-secondary);
        }

        .origin-hashtag {
            background: rgba(0, 255, 136, 0.2);
            color: var(--accent-success);
            border: 1px solid var(--accent-success);
        }

        .metrics {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .metric {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .metric-label {
            font-size: 10px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .metric-value {
            font-weight: 700;
            color: var(--text-primary);
            font-size: 16px;
        }

        .score {
            font-weight: 700;
            color: var(--accent-primary);
            font-size: 18px;
            text-shadow: 0 0 10px rgba(37, 244, 238, 0.5);
        }

        .url-link {
            color: var(--accent-primary);
            text-decoration: none;
            font-weight: 600;
            padding: 6px 12px;
            border: 1px solid var(--accent-primary);
            border-radius: 6px;
            transition: all 0.3s;
            display: inline-block;
        }

        .url-link:hover {
            background: var(--accent-primary);
            color: #000;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(37, 244, 238, 0.4);
        }

        .empty-state {
            text-align: center;
            padding: 80px 20px;
            color: var(--text-secondary);
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background: var(--bg-secondary);
            margin: 5% auto;
            padding: 30px;
            border: 1px solid var(--border-color);
            border-radius: 16px;
            width: 90%;
            max-width: 700px;
            box-shadow: var(--shadow);
            position: relative;
            animation: modalSlideIn 0.3s ease;
            max-height: 90vh;
            overflow-y: auto;
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .close {
            color: var(--text-secondary);
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            position: absolute;
            right: 20px;
            top: 20px;
            transition: color 0.2s;
            line-height: 1;
        }

        .close:hover {
            color: var(--text-primary);
        }

        .modal-content h2 {
            margin-bottom: 20px;
            color: var(--text-primary);
            padding-right: 40px;
        }

        .modal-content h3 {
            margin-top: 20px;
            margin-bottom: 10px;
            color: var(--accent-primary);
            font-size: 16px;
        }

        .modal-content p {
            margin: 8px 0;
            color: var(--text-secondary);
            line-height: 1.6;
        }

        .modal-content ol {
            margin: 10px 0;
            padding-left: 20px;
        }

        .modal-content li {
            margin: 5px 0;
            color: var(--text-secondary);
        }

        .modal-content textarea {
            resize: vertical;
            min-height: 150px;
        }

        .modal-content a {
            color: var(--accent-primary);
            text-decoration: none;
        }

        .modal-content a:hover {
            text-decoration: underline;
        }

        .empty-state h3 {
            margin-bottom: 12px;
            color: var(--text-primary);
            font-size: 20px;
        }

        .empty-state p {
            font-size: 14px;
        }

        /* Loading Animation */
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(37, 244, 238, 0.3);
            border-radius: 50%;
            border-top-color: var(--accent-primary);
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Scrollbar Customizado */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent-primary);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="header-content">
                <div class="header-left">
                    <h1>ü§ñ Automa√ß√£o SAITEC</h1>
                    <p class="subtitle">Sistema Inteligente de Coleta de Tend√™ncias do TikTok</p>
                    <span class="version-badge">Vers√£o 1.0</span>
                </div>
            </div>
        </header>

        <!-- Abas de navega√ß√£o -->
        <div class="tabs" style="display: flex; gap: 10px; padding: 20px 40px 0; border-bottom: 2px solid var(--border-color);">
            <button class="tab-btn active" onclick="showTab('collect')" id="tabCollect">
                üìä Coletar Tend√™ncias
            </button>
            <button class="tab-btn" onclick="showTab('tiktokshop')" id="tabTikTokShop">
                üõçÔ∏è TikTok Shop
            </button>
            <button class="tab-btn" onclick="showTab('history')" id="tabHistory">
                üìö Tend√™ncias Coletadas
            </button>
        </div>

        <!-- Aba: Coletar Tend√™ncias -->
        <div id="tabCollectContent" class="tab-content">
            <div class="controls">
                <div class="control-group">
                    <label for="filterLimit">Quantidade:</label>
                    <select id="filterLimit">
                        <option value="20" selected>20 v√≠deos</option>
                        <option value="50">50 v√≠deos</option>
                        <option value="100">100 v√≠deos</option>
                    </select>
                </div>

                <button class="btn btn-primary" onclick="loadTrends(true)">
                    <span class="loading-spinner" id="refreshSpinner" style="display: none;"></span>
                    üîÑ Coletar TikTok Shop
                </button>
                <a href="#" id="downloadCSV" class="btn btn-download" download>üì• Baixar CSV</a>
            </div>
            
            <div style="padding: 20px 40px; background: var(--bg-tertiary); border-top: 1px solid var(--border-color);">
                <p style="color: var(--text-secondary); font-size: 14px; margin: 0;">
                    üìä <strong>Coleta Simplificada:</strong> O sistema busca especificamente por "TikTok Shop" no For You e ordena os v√≠deos por maiores m√©tricas (likes, coment√°rios, visualiza√ß√µes).
                </p>
            </div>
            
            <!-- Tabela para aba Coletar Tend√™ncias -->
            <div style="padding: 20px 40px; overflow-x: auto;">
                <table style="width: 100%; border-collapse: collapse;">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>V√≠deo</th>
                            <th>Autor</th>
                            <th>Visualiza√ß√µes</th>
                            <th>Curtidas</th>
                            <th>Coment√°rios</th>
                            <th>Score</th>
                            <th>Data/Hora</th>
                            <th>Link</th>
                        </tr>
                    </thead>
                    <tbody id="trendsBodyCollect">
                        <tr>
                            <td colspan="9" class="empty-state">
                                <div class="loading-spinner" style="margin: 0 auto 20px;"></div>
                                <h3>Carregando tend√™ncias...</h3>
                                <p>Aguarde enquanto buscamos os v√≠deos mais curtidos do TikTok</p>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Aba: TikTok Shop -->
        <div id="tabTikTokShopContent" class="tab-content" style="display: none;">
            <div class="controls">
                <div class="control-group">
                    <label for="tiktokShopLimit">Quantidade:</label>
                    <select id="tiktokShopLimit">
                        <option value="20" selected>20 v√≠deos</option>
                        <option value="50">50 v√≠deos</option>
                        <option value="100">100 v√≠deos</option>
                    </select>
                </div>

                <button class="btn btn-primary" onclick="loadTikTokShopTrends(true)">
                    <span class="loading-spinner" id="tiktokShopSpinner" style="display: none;"></span>
                    üîÑ Coletar TikTok Shop
                </button>
                <a href="#" id="downloadTikTokShopCSV" class="btn btn-download" download>üì• Baixar CSV</a>
            </div>
            
            <div style="padding: 20px 40px; background: var(--bg-tertiary); border-top: 1px solid var(--border-color);">
                <p style="color: var(--text-secondary); font-size: 14px; margin: 0;">
                    üõçÔ∏è <strong>Busca TikTok Shop:</strong> O sistema busca v√≠deos diretamente da p√°gina de busca do TikTok por "tiktok shop" e ordena por maiores m√©tricas (likes, coment√°rios, visualiza√ß√µes).
                </p>
            </div>
            
            <!-- Tabela para aba TikTok Shop -->
            <div style="padding: 20px 40px; overflow-x: auto;">
                <table style="width: 100%; border-collapse: collapse;">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>V√≠deo</th>
                            <th>Autor</th>
                            <th>Visualiza√ß√µes</th>
                            <th>Curtidas</th>
                            <th>Coment√°rios</th>
                            <th>Score</th>
                            <th>Data/Hora</th>
                            <th>Link</th>
                        </tr>
                    </thead>
                    <tbody id="trendsBodyTikTokShop">
                        <tr>
                            <td colspan="9" class="empty-state">
                                <h3>Nenhum v√≠deo coletado ainda</h3>
                                <p>Clique em "Coletar TikTok Shop" para buscar v√≠deos</p>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Aba: Tend√™ncias Coletadas -->
        <div id="tabHistoryContent" class="tab-content" style="display: none;">
            <div class="controls" style="padding: 20px 40px;">
                <div class="control-group">
                    <label for="historyDate">Data:</label>
                    <select id="historyDate">
                        <option value="">Carregando datas...</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="historyLimit">Quantidade:</label>
                    <select id="historyLimit">
                        <option value="20" selected>20 v√≠deos</option>
                        <option value="50">50 v√≠deos</option>
                        <option value="100">100 v√≠deos</option>
                    </select>
                </div>
                <button class="btn btn-primary" onclick="loadHistory()">
                    üîÑ Carregar
                </button>
            </div>
            
            <!-- Tabela para aba Tend√™ncias Coletadas -->
            <div style="padding: 20px 40px; overflow-x: auto;">
                <table style="width: 100%; border-collapse: collapse;">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>V√≠deo</th>
                            <th>Autor</th>
                            <th>Visualiza√ß√µes</th>
                            <th>Curtidas</th>
                            <th>Coment√°rios</th>
                            <th>Score</th>
                            <th>Data/Hora</th>
                            <th>Link</th>
                        </tr>
                    </thead>
                    <tbody id="trendsBodyHistory">
                        <tr>
                            <td colspan="9" class="empty-state">
                                <h3>Nenhuma tend√™ncia carregada</h3>
                                <p>Selecione uma data e clique em "Carregar"</p>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Modal para Configurar Cookies -->
        <div id="cookieModal" class="modal" style="display: none;">
            <div class="modal-content">
                <span class="close" onclick="closeCookieModal()">&times;</span>
                <h2>üîê Configurar Login do Kalodata</h2>
                <div style="margin: 20px 0;">
                    <h3>Passo 1: Fazer Login no Kalodata</h3>
                    <p>1. Abra uma nova aba e acesse: <a href="https://www.kalodata.com" target="_blank" style="color: var(--accent-primary);">https://www.kalodata.com</a></p>
                    <p>2. Fa√ßa login com suas credenciais</p>
                    <p>3. Ap√≥s fazer login, volte aqui e continue</p>
                </div>
                <div style="margin: 20px 0;">
                    <h3>Passo 2: Copiar Cookies</h3>
                    <p><strong>M√©todo 1 - Usando Extens√£o (MAIS F√ÅCIL):</strong></p>
                    <ol style="margin-left: 20px; color: var(--text-secondary);">
                        <li>Instale a extens√£o <strong>"Cookie-Editor"</strong> no Chrome/Edge:
                            <br><a href="https://chrome.google.com/webstore/detail/cookie-editor/hlkenndednhfkekhgcdicdfddnkalmdm" target="_blank" style="color: var(--accent-primary);">üîó Baixar Cookie-Editor</a>
                        </li>
                        <li>Ap√≥s fazer login no Kalodata, clique no √≠cone da extens√£o</li>
                        <li>Clique em "Export" ‚Üí "JSON"</li>
                        <li>Cole o JSON completo no campo abaixo</li>
                    </ol>
                    <p style="margin-top: 15px;"><strong>M√©todo 2 - Manual (Chrome/Edge):</strong></p>
                    <ol style="margin-left: 20px; color: var(--text-secondary);">
                        <li>Pressione F12 (ou clique com bot√£o direito ‚Üí Inspecionar)</li>
                        <li>V√° na aba "Application" (Aplicativo)</li>
                        <li>No menu lateral, expanda "Cookies" ‚Üí "https://www.kalodata.com"</li>
                        <li>Copie manualmente os cookies importantes (ex: session, token, etc.)</li>
                        <li>Formate como JSON: <code style="background: var(--bg-tertiary); padding: 2px 6px; border-radius: 4px;">[{"name":"nome","value":"valor","domain":".kalodata.com"}]</code></li>
                    </ol>
                </div>
                <div style="margin: 20px 0;">
                    <label for="cookieJson" style="display: block; margin-bottom: 10px; font-weight: bold;">
                        Cole os cookies aqui (formato JSON):
                    </label>
                    <textarea id="cookieJson" rows="10" style="width: 100%; padding: 10px; background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 8px; font-family: monospace; font-size: 12px;" placeholder='[{"name":"cookie1","value":"valor1","domain":".kalodata.com"},...]'></textarea>
                    <p style="margin-top: 10px; font-size: 12px; color: var(--text-secondary);">
                        üí° Dica: Use uma extens√£o de cookies para exportar facilmente
                    </p>
                </div>
                <div style="margin: 20px 0;">
                    <button class="btn btn-primary" onclick="saveCookies()" style="width: 100%;">
                        üíæ Salvar Cookies e Testar
                    </button>
                </div>
                <div id="cookieStatus" style="margin-top: 15px; padding: 10px; border-radius: 8px; display: none;"></div>
            </div>
        </div>

        <div id="status" class="status" style="display: none;">
            <div id="statusText">üîÑ Carregando tend√™ncias...</div>
            <div class="progress-container" id="progressContainer" style="display: none;">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-text">
                    <span id="progressMessage">Iniciando coleta...</span>
                    <span id="progressPercent">0%</span>
                </div>
            </div>
        </div>

    </div>

    <script>
        let allTrends = [];
        let progressEventSource = null;

        // Fun√ß√£o principal para carregar tend√™ncias
        async function loadTrends(showProgress = false) {
            const statusEl = document.getElementById('status');
            const statusText = document.getElementById('statusText');
            const progressContainer = document.getElementById('progressContainer');
            const progressFill = document.getElementById('progressFill');
            const progressMessage = document.getElementById('progressMessage');
            const progressPercent = document.getElementById('progressPercent');
            const refreshSpinner = document.getElementById('refreshSpinner');
            const tbody = document.getElementById('trendsBodyCollect');
            
            // Mostrar status
            statusEl.style.display = 'block';
            statusEl.className = 'status';
            
            if (showProgress) {
                progressContainer.style.display = 'block';
                progressFill.style.width = '0%';
                progressPercent.textContent = '0%';
                refreshSpinner.style.display = 'inline-block';
            } else {
                progressContainer.style.display = 'none';
            }
            
            tbody.innerHTML = `
                <tr>
                    <td colspan="9" class="empty-state">
                        <div class="loading-spinner" style="margin: 0 auto 20px;"></div>
                        <h3>Carregando tend√™ncias...</h3>
                    </td>
                </tr>
            `;

            try {
                // Coleta simplificada - apenas quantidade
                const limit = document.getElementById('filterLimit').value || '20';
                const country = 'BR'; // Pa√≠s fixo
                
                const url = `/trends/top20?country=${country}&limit=${limit}`;
                
                // Log de in√≠cio
                console.log('[Panel] Iniciando coleta de TikTok Shop...', { country, limit, url });
                
                // Atualizar progresso visual
                if (showProgress) {
                    progressFill.style.width = '10%';
                    progressPercent.textContent = '10%';
                    progressMessage.textContent = 'Buscando TikTok Shop no For You...';
                    statusText.textContent = 'üîÑ Buscando TikTok Shop no For You...';
                }
                
                // Fazer requisi√ß√£o com timeout aumentado (10 minutos para scraping)
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 600000); // 10 minutos
                
                // Atualizar progresso durante a requisi√ß√£o
                const progressInterval = setInterval(() => {
                    if (showProgress) {
                        const current = parseInt(progressPercent.textContent) || 10;
                        if (current < 90) {
                            const newProgress = Math.min(90, current + 5);
                            progressFill.style.width = newProgress + '%';
                            progressPercent.textContent = newProgress + '%';
                            progressMessage.textContent = `Coletando v√≠deos... (${newProgress}%)`;
                            statusText.textContent = `üîÑ Coletando v√≠deos do TikTok Shop... (${newProgress}%)`;
                        }
                    }
                }, 2000); // Atualizar a cada 2 segundos
                
                console.log('[Panel] Fazendo requisi√ß√£o para:', url);
                const startTime = Date.now();
                
                // Usar GET simples
                const response = await fetch(url, {
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                clearInterval(progressInterval);
                
                const elapsedTime = ((Date.now() - startTime) / 1000).toFixed(1);
                console.log(`[Panel] Resposta recebida em ${elapsedTime}s. Status:`, response.status);
                
                // Verificar se a resposta √© JSON
                const contentType = response.headers.get('content-type');
                if (!contentType || !contentType.includes('application/json')) {
                    const text = await response.text();
                    console.error('[Panel] Resposta n√£o √© JSON:', { status: response.status, contentType, text: text.substring(0, 200) });
                    throw new Error(`Resposta n√£o √© JSON. Status: ${response.status}. Resposta: ${text.substring(0, 200)}`);
                }
                
                const result = await response.json();
                console.log('[Panel] Resultado recebido:', { success: result.success, inProgress: result.inProgress, count: result.count });
                
                // Verificar se h√° coleta em andamento
                if (result.inProgress && result.redirectToProgress) {
                    // H√° uma coleta em andamento, conectar ao SSE para mostrar progresso
                    console.log('[Panel] Coleta j√° em andamento, conectando ao progresso...');
                    statusText.textContent = `üîÑ ${result.message || 'Coleta em andamento...'}`;
                    
                    if (showProgress) {
                        progressContainer.style.display = 'block';
                        progressFill.style.width = `${result.progress || 0}%`;
                        progressPercent.textContent = `${result.progress || 0}%`;
                        progressMessage.textContent = result.message || 'Aguardando...';
                    }
                    
                    // Conectar ao SSE para atualiza√ß√µes em tempo real
                    connectToProgress();
                    
                    // Aguardar a coleta terminar e buscar resultados
                    await waitForCollectionComplete();
                    
                    // Buscar resultados ap√≥s coleta completar
                    const finalResponse = await fetch(url);
                    const finalResult = await finalResponse.json();
                    
                    if (finalResult.success) {
                        allTrends = finalResult.data || [];
                        displayTrends(allTrends);
                        
                        refreshSpinner.style.display = 'none';
                        statusEl.className = 'status success';
                        statusText.textContent = `‚úÖ ${allTrends.length} tend√™ncias carregadas com sucesso`;
                        progressContainer.style.display = 'none';
                        
                        setTimeout(() => {
                            statusEl.style.display = 'none';
                        }, 3000);
                    } else {
                        throw new Error(finalResult.error || 'Erro ao carregar tend√™ncias');
                    }
                    
                    return; // Sair da fun√ß√£o aqui
                }
                
                // Se n√£o h√° coleta em andamento, continuar normalmente
                if (!result.success) {
                    throw new Error(result.error || 'Erro ao carregar tend√™ncias');
                }
                
                // Atualizar progresso
                if (showProgress) {
                    progressFill.style.width = '95%';
                    progressPercent.textContent = '95%';
                    progressMessage.textContent = 'Processando resposta...';
                    statusText.textContent = 'üîÑ Processando resposta...';
                }
                
                allTrends = result.data || [];
                displayTrends(allTrends);

                // Fechar conex√£o SSE se estiver aberta
                if (progressEventSource) {
                    progressEventSource.close();
                    progressEventSource = null;
                }

                refreshSpinner.style.display = 'none';
                statusEl.className = 'status success';
                statusText.textContent = `‚úÖ ${allTrends.length} tend√™ncias carregadas com sucesso`;
                progressContainer.style.display = 'none';
                
                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, 3000);

            } catch (error) {
                console.error('[Panel] Erro ao carregar tend√™ncias:', error);
                
                refreshSpinner.style.display = 'none';
                
                // Fechar conex√£o SSE se estiver aberta
                if (progressEventSource) {
                    progressEventSource.close();
                    progressEventSource = null;
                }
                
                statusEl.className = 'status error';
                statusText.textContent = `‚ùå Erro: ${error.message}`;
                progressContainer.style.display = 'none';
                
                tbody.innerHTML = `
                    <tr>
                        <td colspan="9" class="empty-state">
                            <h3>‚ùå Erro ao carregar tend√™ncias</h3>
                            <p>${error.message}</p>
                        </td>
                    </tr>
                `;
                
                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, 10000);
            }
        }

        // Fun√ß√£o para carregar tend√™ncias do TikTok Shop (busca direta)
        async function loadTikTokShopTrends(showProgress = false) {
            const statusEl = document.getElementById('status');
            const statusText = document.getElementById('statusText');
            const progressContainer = document.getElementById('progressContainer');
            const progressFill = document.getElementById('progressFill');
            const progressMessage = document.getElementById('progressMessage');
            const progressPercent = document.getElementById('progressPercent');
            const tiktokShopSpinner = document.getElementById('tiktokShopSpinner');
            const tbody = document.getElementById('trendsBodyTikTokShop');
            
            // Mostrar status
            statusEl.style.display = 'block';
            statusEl.className = 'status';
            
            if (showProgress) {
                progressContainer.style.display = 'block';
                progressFill.style.width = '0%';
                progressPercent.textContent = '0%';
                tiktokShopSpinner.style.display = 'inline-block';
            } else {
                progressContainer.style.display = 'none';
            }
            
            tbody.innerHTML = `
                <tr>
                    <td colspan="9" class="empty-state">
                        <div class="loading-spinner" style="margin: 0 auto 20px;"></div>
                        <h3>Buscando v√≠deos do TikTok Shop...</h3>
                    </td>
                </tr>
            `;

            try {
                const limit = document.getElementById('tiktokShopLimit').value || '20';
                const url = `/trends/tiktokshop?limit=${limit}`;
                
                console.log('[Panel] Iniciando busca TikTok Shop...', { limit, url });
                
                if (showProgress) {
                    progressFill.style.width = '10%';
                    progressPercent.textContent = '10%';
                    progressMessage.textContent = 'Acessando p√°gina de busca do TikTok Shop...';
                    statusText.textContent = 'üîÑ Acessando p√°gina de busca do TikTok Shop...';
                }
                
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 600000);
                
                const progressInterval = setInterval(() => {
                    if (showProgress) {
                        const current = parseInt(progressPercent.textContent) || 10;
                        if (current < 90) {
                            const newProgress = Math.min(90, current + 5);
                            progressFill.style.width = newProgress + '%';
                            progressPercent.textContent = newProgress + '%';
                            progressMessage.textContent = `Coletando v√≠deos do TikTok Shop... (${newProgress}%)`;
                            statusText.textContent = `üîÑ Coletando v√≠deos do TikTok Shop... (${newProgress}%)`;
                        }
                    }
                }, 2000);
                
                const startTime = Date.now();
                const response = await fetch(url, {
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                clearInterval(progressInterval);
                
                const elapsedTime = ((Date.now() - startTime) / 1000).toFixed(1);
                console.log(`[Panel] Resposta recebida em ${elapsedTime}s. Status:`, response.status);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const result = await response.json();
                console.log('[Panel] Resultado TikTok Shop:', { success: result.success, count: result.count });
                
                if (!result.success) {
                    throw new Error(result.error || 'Erro ao buscar v√≠deos do TikTok Shop');
                }

                const trends = result.data || [];
                allTrends = trends;
                displayTrends(trends, document.getElementById('trendsBodyCollect'));
                
                // Atualizar link CSV
                updateTikTokShopCSVLink(limit);
                
                statusEl.className = 'status success';
                statusText.textContent = `‚úÖ ${trends.length} v√≠deos do TikTok Shop encontrados`;
                
                if (showProgress) {
                    progressFill.style.width = '100%';
                    progressPercent.textContent = '100%';
                    progressMessage.textContent = 'Conclu√≠do!';
                    tiktokShopSpinner.style.display = 'none';
                }
                
                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, 5000);
                
            } catch (error) {
                console.error('[Panel] Erro ao buscar TikTok Shop:', error);
                statusEl.className = 'status error';
                statusText.textContent = `‚ùå Erro: ${error.message}`;
                
                if (showProgress) {
                    tiktokShopSpinner.style.display = 'none';
                }
                
                tbody.innerHTML = `
                    <tr>
                        <td colspan="9" class="empty-state">
                            <h3>‚ùå Erro ao buscar v√≠deos do TikTok Shop</h3>
                            <p><strong>Detalhes:</strong> ${error.message}</p>
                            <button onclick="loadTikTokShopTrends(true)" style="margin-top: 15px; padding: 10px 20px; background: var(--accent-primary); color: white; border: none; border-radius: 6px; cursor: pointer;">
                                üîÑ Tentar Novamente
                            </button>
                        </td>
                    </tr>
                `;
            }
        }

        function updateTikTokShopCSVLink(limit) {
            const csvLink = document.getElementById('downloadTikTokShopCSV');
            if (csvLink) {
                csvLink.href = `/trends/tiktokshop.csv?limit=${limit}`;
            }
        }

        async function loadTrendsWithLogin() {
            const statusEl = document.getElementById('status');
            const statusText = document.getElementById('statusText');
            const progressContainer = document.getElementById('progressContainer');
            const progressFill = document.getElementById('progressFill');
            const progressMessage = document.getElementById('progressMessage');
            const progressPercent = document.getElementById('progressPercent');
            const tbody = document.getElementById('trendsBodyCollect');
            
            // Mostrar aviso sobre login manual
            statusEl.style.display = 'block';
            statusEl.className = 'status loading';
            statusText.textContent = 'üîê Iniciando modo login manual...';
            progressContainer.style.display = 'block';
            progressFill.style.width = '10%';
            progressPercent.textContent = '10%';
            progressMessage.textContent = 'Abrindo navegador para login manual...';
            
            tbody.innerHTML = `
                <tr>
                    <td colspan="8" class="empty-state">
                        <div style="text-align: center; padding: 20px;">
                            <h3>üîê Modo Login Manual Ativado</h3>
                            <p style="margin: 15px 0; color: var(--text-secondary);">
                                O navegador ser√° aberto na VPS. Se voc√™ tiver acesso via VNC ou SSH com X11 forwarding, 
                                poder√° fazer login manualmente no Kalodata.
                            </p>
                            <p style="margin: 15px 0; color: var(--accent-primary);">
                                ‚ö†Ô∏è O sistema aguardar√° at√© 5 minutos para voc√™ fazer login.
                            </p>
                            <p style="margin: 15px 0; color: var(--text-secondary);">
                                Ap√≥s o login, a coleta continuar√° automaticamente.
                            </p>
                        </div>
                    </td>
                </tr>
            `;

            try {
                const niche = document.getElementById('filterNiche').value || '';
                const limit = document.getElementById('filterLimit').value || '20';
                const country = document.getElementById('filterCountry')?.value || 'BR';
                
                // Coletar filtros avan√ßados
                const filters = {};
                
                // Filtros b√°sicos
                if (niche) filters.niche = niche;
                if (country) filters.country = country;
                
                // Filtros de idioma
                const language = document.getElementById('filterLanguage')?.value;
                if (language) filters.language = language;
                
                // Filtros de m√©tricas
                const minViews = document.getElementById('filterMinViews')?.value;
                if (minViews) filters.minViews = parseInt(minViews);
                
                const minLikes = document.getElementById('filterMinLikes')?.value;
                if (minLikes) filters.minLikes = parseInt(minLikes);
                
                const minER = document.getElementById('filterMinER')?.value;
                if (minER) filters.minER = parseFloat(minER);
                
                const maxAge = document.getElementById('filterMaxAge')?.value;
                if (maxAge) filters.maxAgeHours = parseInt(maxAge);
                
                const growthRate = document.getElementById('filterGrowthRate')?.value;
                if (growthRate) filters.growthRate = parseFloat(growthRate);
                
                // Filtros de conte√∫do
                const keywords = document.getElementById('filterKeywords')?.value;
                if (keywords) {
                    filters.keywords = keywords.split(',').map(k => k.trim()).filter(k => k);
                }
                
                const requiredHashtags = document.getElementById('filterRequiredHashtags')?.value;
                if (requiredHashtags) {
                    filters.requiredHashtags = requiredHashtags.split(',').map(h => h.trim().replace(/^#/, '')).filter(h => h);
                }
                
                const excludeCreators = document.getElementById('filterExcludeCreators')?.value;
                if (excludeCreators) {
                    filters.excludeCreators = excludeCreators.split(',').map(c => c.trim().replace(/^@/, '')).filter(c => c);
                }
                
                // Filtros de criadores
                const minFollowers = document.getElementById('filterMinFollowers')?.value;
                if (minFollowers) filters.minFollowers = parseInt(minFollowers);
                
                const maxFollowers = document.getElementById('filterMaxFollowers')?.value;
                if (maxFollowers) filters.maxFollowers = parseInt(maxFollowers);
                
                // Construir URL com todos os filtros
                const params = new URLSearchParams();
                params.append('niche', niche || '');
                params.append('country', country);
                params.append('limit', limit);
                
                const url = `/trends/top20?${params.toString()}`;
                
                // Fazer requisi√ß√£o POST com filtros no body se houver filtros avan√ßados
                const hasAdvancedFilters = Object.keys(filters).length > 3; // Mais que niche, country, limit
                
                // Fazer requisi√ß√£o com timeout aumentado (10 minutos para scraping)
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 600000); // 10 minutos
                
                let response;
                if (hasAdvancedFilters) {
                    // Usar POST para filtros avan√ßados
                    response = await fetch('/trends/top20', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            niche: niche || null,
                            country: country,
                            limit: parseInt(limit),
                            filters: filters
                        }),
                        signal: controller.signal
                    });
                } else {
                    // Usar GET para filtros simples
                    response = await fetch(url, {
                        signal: controller.signal
                    });
                }
                
                clearTimeout(timeoutId);
                
                // Verificar se a resposta √© JSON
                const contentType = response.headers.get('content-type');
                if (!contentType || !contentType.includes('application/json')) {
                    const text = await response.text();
                    throw new Error(`Resposta n√£o √© JSON. Status: ${response.status}. Resposta: ${text.substring(0, 200)}`);
                }
                
                // Verificar se h√° coleta em andamento
                const result = await response.json();
                
                if (result.inProgress && result.redirectToProgress) {
                    // H√° uma coleta em andamento, conectar ao SSE para mostrar progresso
                    console.log('[Panel] Coleta j√° em andamento, conectando ao progresso...');
                    statusText.textContent = `üîÑ ${result.message || 'Coleta em andamento...'}`;
                    
                    if (showProgress) {
                        progressContainer.style.display = 'block';
                        progressFill.style.width = `${result.progress || 0}%`;
                        progressPercent.textContent = `${result.progress || 0}%`;
                        progressMessage.textContent = result.message || 'Aguardando...';
                    }
                    
                    // Conectar ao SSE para atualiza√ß√µes em tempo real
                    connectToProgress();
                    
                    // Aguardar a coleta terminar e buscar resultados
                    await waitForCollectionComplete();
                    
                    // Buscar resultados ap√≥s coleta completar
                    const finalResponse = await fetch(url);
                    const finalResult = await finalResponse.json();
                    
                    if (finalResult.success) {
                        allTrends = finalResult.data || [];
                        displayTrends(allTrends);
                        
                        refreshSpinner.style.display = 'none';
                        statusEl.className = 'status success';
                        statusText.textContent = `‚úÖ ${allTrends.length} tend√™ncias carregadas com sucesso`;
                        progressContainer.style.display = 'none';
                        
                        setTimeout(() => {
                            statusEl.style.display = 'none';
                        }, 3000);
                    } else {
                        throw new Error(finalResult.error || 'Erro ao carregar tend√™ncias');
                    }
                    
                    return; // Sair da fun√ß√£o aqui
                }
                
                // Se n√£o h√° coleta em andamento, continuar normalmente
                if (!result.success) {
                    throw new Error(result.error || 'Erro ao carregar tend√™ncias');
                }
                
                // Atualizar progresso
                if (showProgress) {
                    progressFill.style.width = '95%';
                    progressPercent.textContent = '95%';
                    progressMessage.textContent = 'Processando resposta...';
                    statusText.textContent = 'üîÑ Processando resposta...';
                }
                
                allTrends = result.data || [];
                displayTrends(allTrends);

                // Fechar conex√£o SSE se estiver aberta
                if (progressEventSource) {
                    progressEventSource.close();
                    progressEventSource = null;
                }

                refreshSpinner.style.display = 'none';
                statusEl.className = 'status success';
                statusText.textContent = `‚úÖ ${allTrends.length} tend√™ncias carregadas com sucesso`;
                progressContainer.style.display = 'none';
                
                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, 3000);

            } catch (error) {
                console.error('Erro:', error);
                statusEl.className = 'status error';
                statusText.textContent = `‚ùå Erro: ${error.message}`;
                progressContainer.style.display = 'none';
                
                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, 10000);
            }
        }

        function connectToProgress() {
            // Fechar conex√£o anterior se existir
            if (progressEventSource) {
                progressEventSource.close();
            }

            const progressFill = document.getElementById('progressFill');
            const progressMessage = document.getElementById('progressMessage');
            const progressPercent = document.getElementById('progressPercent');
            const statusText = document.getElementById('statusText');
            const progressContainer = document.getElementById('progressContainer');
            
            progressContainer.style.display = 'block';

            // Conectar ao SSE
            progressEventSource = new EventSource('/trends/collect/progress');
            
            progressEventSource.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    
                    // Atualizar barra de progresso
                    const progress = Math.min(100, Math.max(0, data.progress || 0));
                    progressFill.style.width = progress + '%';
                    progressPercent.textContent = progress + '%';
                    
                    // Atualizar mensagem
                    const message = data.message || 'Processando...';
                    progressMessage.textContent = message;
                    statusText.textContent = `üîÑ ${message}`;
                    
                    // Se conclu√≠do ou erro, fechar conex√£o
                    if (data.status === 'completed' || data.status === 'error') {
                        setTimeout(() => {
                            if (progressEventSource) {
                                progressEventSource.close();
                                progressEventSource = null;
                            }
                            progressContainer.style.display = 'none';
                        }, 2000);
                    }
                } catch (e) {
                    console.error('Erro ao processar evento SSE:', e);
                }
            };

            progressEventSource.onerror = function(error) {
                console.error('Erro na conex√£o SSE:', error);
                if (progressEventSource) {
                    progressEventSource.close();
                    progressEventSource = null;
                }
                progressContainer.style.display = 'none';
            };
        }

        // Fun√ß√£o para aguardar conclus√£o da coleta usando SSE
        async function waitForCollectionComplete() {
            return new Promise((resolve) => {
                // Usar SSE para detectar quando a coleta terminar
                let completed = false;
                
                // Se j√° temos uma conex√£o SSE, usar ela
                if (progressEventSource) {
                    const originalOnMessage = progressEventSource.onmessage;
                    
                    progressEventSource.onmessage = function(event) {
                        try {
                            const data = JSON.parse(event.data);
                            
                            // Chamar handler original
                            if (originalOnMessage) {
                                originalOnMessage.call(progressEventSource, event);
                            }
                            
                            // Se completou ou erro, resolver
                            if (data.status === 'completed' || data.status === 'error') {
                                if (!completed) {
                                    completed = true;
                                    setTimeout(() => resolve(), 1000); // Aguardar 1s para garantir que dados foram salvos
                                }
                            }
                        } catch (e) {
                            console.error('[Panel] Erro ao processar evento SSE:', e);
                        }
                    };
                    
                    // Timeout de seguran√ßa (10 minutos)
                    setTimeout(() => {
                        if (!completed) {
                            completed = true;
                            resolve();
                        }
                    }, 600000);
                } else {
                    // Fallback: polling menos frequente se SSE n√£o estiver dispon√≠vel
                    let attempts = 0;
                    const maxAttempts = 60; // M√°ximo 60 tentativas (10 minutos com intervalo de 10s)
                    
                    const checkInterval = setInterval(async () => {
                        attempts++;
                        
                        try {
                            const limit = document.getElementById('filterLimit')?.value || '20';
                            const country = 'BR';
                            const url = `/trends/top20?country=${country}&limit=${limit}`;
                            
                            const response = await fetch(url);
                            
                            // Se receber 429, aguardar mais tempo antes de tentar novamente
                            if (response.status === 429) {
                                console.log('[Panel] Rate limit atingido, aguardando mais tempo...');
                                clearInterval(checkInterval);
                                
                                // Aguardar 30 segundos antes de tentar novamente
                                setTimeout(() => {
                                    if (!completed && attempts < maxAttempts) {
                                        checkInterval = setInterval(arguments.callee, 10000);
                                    } else {
                                        resolve();
                                    }
                                }, 30000);
                                return;
                            }
                            
                            if (!response.ok) {
                                throw new Error(`HTTP ${response.status}`);
                            }
                            
                            const result = await response.json();
                            
                            if (!result.inProgress) {
                                clearInterval(checkInterval);
                                completed = true;
                                resolve();
                            }
                        } catch (error) {
                            console.error('[Panel] Erro ao verificar status:', error);
                            
                            // Se for erro de rate limit, aguardar mais
                            if (error.message.includes('429') || error.message.includes('Muitas requisi√ß√µes')) {
                                clearInterval(checkInterval);
                                setTimeout(() => {
                                    if (!completed && attempts < maxAttempts) {
                                        checkInterval = setInterval(arguments.callee, 15000);
                                    } else {
                                        completed = true;
                                        resolve();
                                    }
                                }, 30000);
                                return;
                            }
                            
                            // Se exceder tentativas, resolver
                            if (attempts >= maxAttempts) {
                                clearInterval(checkInterval);
                                completed = true;
                                resolve();
                            }
                        }
                    }, 10000); // Verificar a cada 10 segundos (menos frequente)
                    
                    // Timeout de seguran√ßa (10 minutos)
                    setTimeout(() => {
                        if (!completed) {
                            clearInterval(checkInterval);
                            completed = true;
                            resolve();
                        }
                    }, 600000);
                }
            });
        }

        // Fun√ß√£o para determinar qual tbody usar baseado na aba ativa
        function getCurrentTbody() {
            const activeTab = document.querySelector('.tab-btn.active');
            if (activeTab && activeTab.id === 'tabTikTokShop') {
                return document.getElementById('trendsBodyTikTokShop');
            } else if (activeTab && activeTab.id === 'tabHistory') {
                return document.getElementById('trendsBodyHistory');
            } else {
                return document.getElementById('trendsBodyCollect');
            }
        }

        function displayTrends(trends, targetTbody = null) {
            const tbody = targetTbody || getCurrentTbody();
            
            if (!tbody) {
                console.error('[Panel] Tbody n√£o encontrado!');
                return;
            }

            if (trends.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="9" class="empty-state">
                            <h3>Nenhuma tend√™ncia encontrada</h3>
                            <p>Tente ajustar os filtros ou aguarde alguns segundos para nova coleta</p>
                        </td>
                    </tr>
                `;
                return;
            }

            tbody.innerHTML = trends.map((trend, index) => {
                const titleDisplay = escapeHtml(trend.title || 'V√≠deo sem t√≠tulo');
                const views = (trend.metrics?.views || trend.views || 0).toLocaleString('pt-BR');
                const likes = (trend.metrics?.likes || trend.likes || 0).toLocaleString('pt-BR');
                const comments = (trend.metrics?.comments || trend.comments || 0).toLocaleString('pt-BR');
                // Garantir que score seja um n√∫mero antes de usar toFixed
                const scoreValue = parseFloat(trend.score || trend.engagementScore || trend.engagement_score || 0);
                const score = isNaN(scoreValue) ? '0.00' : scoreValue.toFixed(2);
                
                return `
                    <tr>
                        <td><strong style="color: var(--accent-primary);">${index + 1}</strong></td>
                        <td class="trend-title">
                            ${trend.thumbnail ? `<img src="${trend.thumbnail}" style="width: 80px; height: 80px; object-fit: cover; border-radius: 6px; margin-right: 12px; vertical-align: middle;" />` : ''}
                            <div>
                                <strong style="color: var(--text-primary);">${titleDisplay}</strong>
                                ${trend.mainHashtag ? `<div style="color: var(--accent-primary); font-size: 12px; margin-top: 4px;">${trend.mainHashtag}</div>` : ''}
                            </div>
                        </td>
                        <td>${trend.author ? `@${trend.author}` : 'N/A'}</td>
                        <td><strong style="color: var(--accent-success);">${views}</strong></td>
                        <td><strong style="color: var(--accent-secondary);">${likes}</strong></td>
                        <td>${comments}</td>
                        <td><span class="status success" style="padding: 4px 8px; border-radius: 4px; font-size: 12px;">${score}</span></td>
                        <td style="font-size: 12px; color: var(--text-secondary);">
                            ${trend.collectedAt ? new Date(trend.collectedAt).toLocaleString('pt-BR') : 'N/A'}
                        </td>
                        <td>
                            ${trend.url && trend.url.startsWith('http')
                                ? `<a href="${trend.url}" target="_blank" class="url-link">Abrir ‚Üí</a>`
                                : `<span style="color: var(--text-secondary); font-style: italic;">URL n√£o dispon√≠vel</span>`}
                        </td>
                    </tr>
                `;
            }).join('');
        }

        function formatNumber(num) {
            if (num >= 1000000) {
                return (num / 1000000).toFixed(1) + 'M';
            }
            if (num >= 1000) {
                return (num / 1000).toFixed(1) + 'K';
            }
            return num.toString();
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function applyFilters() {
            // Recarregar tend√™ncias com novos filtros
            loadTrends(false);
        }

        // Atualizar link do CSV dinamicamente
        function updateCSVLink() {
            const csvLink = document.getElementById('downloadCSV');
            if (!csvLink) return; // Se o elemento n√£o existir, sair
            
            const filterLimitEl = document.getElementById('filterLimit');
            const limit = filterLimitEl ? filterLimitEl.value || '20' : '20';
            const country = 'BR';
            
            let csvUrl = `/trends/top20.csv?country=${country}&limit=${limit}`;
            csvLink.href = csvUrl;
        }

        // Event listeners
        const filterLimitEl = document.getElementById('filterLimit');
        if (filterLimitEl) {
            filterLimitEl.addEventListener('change', () => {
                updateCSVLink();
            });
        }

        // Atualizar link do CSV ao carregar
        updateCSVLink();
        
        // Carregar datas dispon√≠veis para hist√≥rico
        loadAvailableDates();

        // Fun√ß√£o para mostrar/ocultar filtros avan√ßados
        function toggleAdvancedFilters() {
            const panel = document.getElementById('advancedFiltersPanel');
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
            } else {
                panel.style.display = 'none';
            }
        }

        // Fun√ß√£o para resetar filtros avan√ßados
        function resetAdvancedFilters() {
            document.getElementById('filterCountry').value = 'BR';
            document.getElementById('filterLanguage').value = '';
            document.getElementById('filterMinViews').value = '';
            document.getElementById('filterMinLikes').value = '';
            document.getElementById('filterMinER').value = '';
            document.getElementById('filterMaxAge').value = '';
            document.getElementById('filterGrowthRate').value = '';
            document.getElementById('filterKeywords').value = '';
            document.getElementById('filterRequiredHashtags').value = '';
            document.getElementById('filterExcludeCreators').value = '';
            document.getElementById('filterMinFollowers').value = '';
            document.getElementById('filterMaxFollowers').value = '';
        }

        // Fun√ß√£o para alternar entre abas
        function showTab(tabName) {
            // Esconder todos os conte√∫dos
            document.getElementById('tabCollectContent').style.display = 'none';
            document.getElementById('tabTikTokShopContent').style.display = 'none';
            document.getElementById('tabHistoryContent').style.display = 'none';
            
            // Remover classe active de todos os bot√µes
            document.getElementById('tabCollect').classList.remove('active');
            document.getElementById('tabTikTokShop').classList.remove('active');
            document.getElementById('tabHistory').classList.remove('active');
            
            // Remover classe active de todos os bot√µes
            document.getElementById('tabCollect').classList.remove('active');
            document.getElementById('tabHistory').classList.remove('active');
            
            // Mostrar conte√∫do da aba selecionada
            if (tabName === 'collect') {
                document.getElementById('tabCollectContent').style.display = 'block';
                document.getElementById('tabCollect').classList.add('active');
            } else if (tabName === 'tiktokshop') {
                document.getElementById('tabTikTokShopContent').style.display = 'block';
                document.getElementById('tabTikTokShop').classList.add('active');
            } else if (tabName === 'history') {
                document.getElementById('tabHistoryContent').style.display = 'block';
                document.getElementById('tabHistory').classList.add('active');
                loadHistory(); // Carregar hist√≥rico automaticamente
            }
        }

        // Carregar datas dispon√≠veis
        async function loadAvailableDates() {
            try {
                const response = await fetch('/trends/collected/dates');
                const result = await response.json();
                
                const dateSelect = document.getElementById('historyDate');
                if (result.success && result.data.length > 0) {
                    dateSelect.innerHTML = '<option value="">Todas as datas</option>';
                    result.data.forEach(item => {
                        const date = new Date(item.date + 'T00:00:00');
                        const dateStr = date.toLocaleDateString('pt-BR');
                        dateSelect.innerHTML += `<option value="${item.date}">${dateStr} (${item.count} v√≠deos)</option>`;
                    });
                } else {
                    dateSelect.innerHTML = '<option value="">Nenhuma data dispon√≠vel</option>';
                }
            } catch (error) {
                console.error('[Panel] Erro ao carregar datas:', error);
                document.getElementById('historyDate').innerHTML = '<option value="">Erro ao carregar datas</option>';
            }
        }

        // Carregar hist√≥rico de tend√™ncias coletadas
        async function loadHistory() {
            const tbody = document.getElementById('trendsBodyHistory');
            const statusEl = document.getElementById('status');
            const statusText = document.getElementById('statusText');
            
            statusEl.style.display = 'block';
            statusEl.className = 'status loading';
            statusText.textContent = 'üîÑ Carregando hist√≥rico...';
            
            tbody.innerHTML = `
                <tr>
                    <td colspan="9" class="empty-state">
                        <div class="loading-spinner" style="margin: 0 auto 20px;"></div>
                        <h3>Carregando hist√≥rico...</h3>
                    </td>
                </tr>
            `;

            try {
                const date = document.getElementById('historyDate').value || '';
                const limit = document.getElementById('historyLimit').value || '20';
                
                const url = `/trends/latest?limit=${limit}${date ? `&date=${date}` : ''}`;
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const result = await response.json();
                
                if (!result.success) {
                    throw new Error(result.error || 'Erro ao carregar hist√≥rico');
                }

                const trends = result.data || [];
                displayTrends(trends, document.getElementById('trendsBodyHistory'));
                
                statusEl.className = 'status success';
                statusText.textContent = `‚úÖ ${trends.length} tend√™ncias carregadas do hist√≥rico`;
                
                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, 3000);

            } catch (error) {
                console.error('[Panel] Erro ao carregar hist√≥rico:', error);
                statusEl.className = 'status error';
                statusText.textContent = `‚ùå Erro: ${error.message}`;
                
                tbody.innerHTML = `
                    <tr>
                        <td colspan="9" class="empty-state">
                            <h3>‚ùå Erro ao carregar hist√≥rico</h3>
                            <p><strong>Detalhes:</strong> ${error.message}</p>
                            <button onclick="loadHistory()" style="margin-top: 15px; padding: 10px 20px; background: var(--accent-primary); color: white; border: none; border-radius: 6px; cursor: pointer;">
                                üîÑ Tentar Novamente
                            </button>
                        </td>
                    </tr>
                `;
            }
        }

        // Fun√ß√µes do Modal de Cookies
        function showCookieModal() {
            document.getElementById('cookieModal').style.display = 'block';
        }

        function closeCookieModal() {
            document.getElementById('cookieModal').style.display = 'none';
            document.getElementById('cookieStatus').style.display = 'none';
            document.getElementById('cookieJson').value = '';
        }

        // Fechar modal ao clicar fora
        window.onclick = function(event) {
            const modal = document.getElementById('cookieModal');
            if (event.target === modal) {
                closeCookieModal();
            }
        }

        async function saveCookies() {
            const cookieJson = document.getElementById('cookieJson').value.trim();
            const statusDiv = document.getElementById('cookieStatus');
            
            if (!cookieJson) {
                statusDiv.style.display = 'block';
                statusDiv.style.background = 'rgba(255, 0, 80, 0.1)';
                statusDiv.style.color = 'var(--accent-secondary)';
                statusDiv.style.border = '1px solid var(--accent-secondary)';
                statusDiv.textContent = '‚ùå Por favor, cole os cookies antes de salvar.';
                return;
            }

            try {
                // Validar JSON
                const cookies = JSON.parse(cookieJson);
                if (!Array.isArray(cookies)) {
                    throw new Error('Os cookies devem ser um array JSON');
                }

                // Enviar para o servidor
                statusDiv.style.display = 'block';
                statusDiv.style.background = 'rgba(37, 244, 238, 0.1)';
                statusDiv.style.color = 'var(--accent-primary)';
                statusDiv.style.border = '1px solid var(--accent-primary)';
                statusDiv.textContent = '‚è≥ Salvando cookies...';

                const response = await fetch('/api/kalodata/cookies', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ cookies })
                });

                const result = await response.json();

                if (result.success) {
                    statusDiv.style.background = 'rgba(0, 255, 136, 0.1)';
                    statusDiv.style.color = 'var(--accent-success)';
                    statusDiv.style.border = '1px solid var(--accent-success)';
                    statusDiv.innerHTML = '‚úÖ Cookies salvos com sucesso!<br><small>Testando login...</small>';
                    
                    // Testar login fazendo uma requisi√ß√£o
                    setTimeout(async () => {
                        try {
                            const testResponse = await fetch('/trends/top20?limit=5');
                            const testResult = await testResponse.json();
                            
                            if (testResult.success && testResult.count > 0) {
                                statusDiv.innerHTML = '‚úÖ Cookies salvos e testados com sucesso!<br><small>Login funcionando corretamente.</small>';
                                setTimeout(() => {
                                    closeCookieModal();
                                    loadTrends(true);
                                }, 2000);
                            } else {
                                statusDiv.innerHTML = '‚ö†Ô∏è Cookies salvos, mas nenhuma tend√™ncia foi coletada.<br><small>Verifique se os cookies est√£o corretos.</small>';
                            }
                        } catch (error) {
                            statusDiv.innerHTML = '‚ö†Ô∏è Cookies salvos, mas erro ao testar.<br><small>' + error.message + '</small>';
                        }
                    }, 2000);
                } else {
                    throw new Error(result.error || 'Erro ao salvar cookies');
                }
            } catch (error) {
                statusDiv.style.display = 'block';
                statusDiv.style.background = 'rgba(255, 0, 80, 0.1)';
                statusDiv.style.color = 'var(--accent-secondary)';
                statusDiv.style.border = '1px solid var(--accent-secondary)';
                statusDiv.textContent = '‚ùå Erro: ' + error.message;
            }
        }

        // Fun√ß√µes do Modal de Cookies
        function showCookieModal() {
            document.getElementById('cookieModal').style.display = 'block';
        }

        function closeCookieModal() {
            document.getElementById('cookieModal').style.display = 'none';
            document.getElementById('cookieStatus').style.display = 'none';
            document.getElementById('cookieJson').value = '';
        }

        // Fechar modal ao clicar fora
        window.onclick = function(event) {
            const modal = document.getElementById('cookieModal');
            if (event.target === modal) {
                closeCookieModal();
            }
        }

        async function saveCookies() {
            const cookieJson = document.getElementById('cookieJson').value.trim();
            const statusDiv = document.getElementById('cookieStatus');
            
            if (!cookieJson) {
                statusDiv.style.display = 'block';
                statusDiv.style.background = 'rgba(255, 0, 80, 0.1)';
                statusDiv.style.color = 'var(--accent-secondary)';
                statusDiv.style.border = '1px solid var(--accent-secondary)';
                statusDiv.style.padding = '10px';
                statusDiv.style.borderRadius = '8px';
                statusDiv.textContent = '‚ùå Por favor, cole os cookies antes de salvar.';
                return;
            }

            try {
                // Validar JSON
                const cookies = JSON.parse(cookieJson);
                if (!Array.isArray(cookies)) {
                    throw new Error('Os cookies devem ser um array JSON');
                }

                // Enviar para o servidor
                statusDiv.style.display = 'block';
                statusDiv.style.background = 'rgba(37, 244, 238, 0.1)';
                statusDiv.style.color = 'var(--accent-primary)';
                statusDiv.style.border = '1px solid var(--accent-primary)';
                statusDiv.style.padding = '10px';
                statusDiv.style.borderRadius = '8px';
                statusDiv.textContent = '‚è≥ Salvando cookies...';

                const response = await fetch('/api/kalodata/cookies', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ cookies })
                });

                const result = await response.json();

                if (result.success) {
                    statusDiv.style.background = 'rgba(0, 255, 136, 0.1)';
                    statusDiv.style.color = 'var(--accent-success)';
                    statusDiv.style.border = '1px solid var(--accent-success)';
                    statusDiv.innerHTML = '‚úÖ Cookies salvos com sucesso!<br><small>Testando login (pode levar alguns segundos)...</small>';
                    
                    // Testar login fazendo uma requisi√ß√£o com timeout
                    const testTimeout = setTimeout(() => {
                        statusDiv.innerHTML = '‚úÖ Cookies salvos com sucesso!<br><small>‚ö†Ô∏è Teste demorou muito. Voc√™ pode fechar este modal e tentar coletar tend√™ncias.</small><br><button onclick="closeCookieModal(); loadTrends(true);" style="margin-top: 10px; padding: 8px 16px; background: var(--accent-primary); color: white; border: none; border-radius: 6px; cursor: pointer;">Fechar e Testar Coleta</button>';
                    }, 30000); // 30 segundos de timeout
                    
                    setTimeout(async () => {
                        try {
                            // Criar AbortController para timeout
                            const controller = new AbortController();
                            const timeoutId = setTimeout(() => controller.abort(), 25000); // 25 segundos
                            
                            const testResponse = await fetch('/trends/top20?limit=5', {
                                signal: controller.signal
                            });
                            
                            clearTimeout(timeoutId);
                            clearTimeout(testTimeout);
                            
                            if (!testResponse.ok) {
                                throw new Error(`HTTP ${testResponse.status}: ${testResponse.statusText}`);
                            }
                            
                            const testResult = await testResponse.json();
                            
                            if (testResult.success && testResult.count > 0) {
                                statusDiv.innerHTML = '‚úÖ Cookies salvos e testados com sucesso!<br><small>Login funcionando corretamente. ' + testResult.count + ' tend√™ncias coletadas.</small>';
                                setTimeout(() => {
                                    closeCookieModal();
                                    loadTrends(true);
                                }, 2000);
                            } else if (testResult.success && testResult.count === 0) {
                                statusDiv.innerHTML = '‚úÖ Cookies salvos!<br><small>‚ö†Ô∏è Nenhuma tend√™ncia coletada ainda. Voc√™ pode fechar e tentar coletar novamente.</small><br><button onclick="closeCookieModal(); loadTrends(true);" style="margin-top: 10px; padding: 8px 16px; background: var(--accent-primary); color: white; border: none; border-radius: 6px; cursor: pointer;">Fechar e Tentar Coletar</button>';
                            } else {
                                statusDiv.innerHTML = '‚úÖ Cookies salvos!<br><small>‚ö†Ô∏è Erro no teste: ' + (testResult.error || 'Desconhecido') + '</small><br><button onclick="closeCookieModal(); loadTrends(true);" style="margin-top: 10px; padding: 8px 16px; background: var(--accent-primary); color: white; border: none; border-radius: 6px; cursor: pointer;">Fechar e Tentar Coletar</button>';
                            }
                        } catch (error) {
                            clearTimeout(testTimeout);
                            if (error.name === 'AbortError') {
                                statusDiv.innerHTML = '‚úÖ Cookies salvos!<br><small>‚ö†Ô∏è Teste demorou muito (timeout). Voc√™ pode fechar e tentar coletar produtos.</small><br><button onclick="closeCookieModal(); loadTrends(true);" style="margin-top: 10px; padding: 8px 16px; background: var(--accent-primary); color: white; border: none; border-radius: 6px; cursor: pointer;">Fechar e Testar Coleta</button>';
                            } else {
                                statusDiv.innerHTML = '‚úÖ Cookies salvos!<br><small>‚ö†Ô∏è Erro ao testar: ' + error.message + '</small><br><button onclick="closeCookieModal(); loadTrends(true);" style="margin-top: 10px; padding: 8px 16px; background: var(--accent-primary); color: white; border: none; border-radius: 6px; cursor: pointer;">Fechar e Tentar Coletar</button>';
                            }
                        }
                    }, 2000);
                } else {
                    throw new Error(result.error || 'Erro ao salvar cookies');
                }
            } catch (error) {
                statusDiv.style.display = 'block';
                statusDiv.style.background = 'rgba(255, 0, 80, 0.1)';
                statusDiv.style.color = 'var(--accent-secondary)';
                statusDiv.style.border = '1px solid var(--accent-secondary)';
                statusDiv.style.padding = '10px';
                statusDiv.style.borderRadius = '8px';
                statusDiv.textContent = '‚ùå Erro: ' + error.message;
            }
        }

        // Carregar produtos ao carregar a p√°gina
        loadTrends();

        // Auto-refresh a cada 5 minutos
        setInterval(() => loadTrends(false), 5 * 60 * 1000);
    </script>
</body>
</html>
